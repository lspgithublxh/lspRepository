<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:security="http://www.springframework.org/schema/security"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/security 
        http://www.springframework.org/schema/security/spring-security-4.2.xsd "> 
	
	<!--认证的时候被使用，即第一次访问、登录本项目时候使用..一是认证:看存不存在。二是存在的时候利用配置信息生成
         该session的securityContext的基本信息(即用户信息：姓名、密码、权限等等，当然可以自己加:如果使用自己的userService)	-->
         <!-- 同时注意userService这个bean就不能和自己写的service的注解名称一样了 -->
	<!--  -->
	
<!--security最基本配置， 一是登录时的认证， 二是任何httpweb请求的权权匹配检查，配则放过不配则拦截-->
    <!--可以改成入口点配置，来加入自己的filter基本加密 -->
	<!--自动配置还会在首次访问时(没有session,securityContext)时返回自己的登录界面 -->
	<!-- 静态资源不拦截 -->
	<security:http pattern="*.css" security="none"></security:http>
	<security:http pattern="*.js" security="none"></security:http>
	<security:http pattern="/view/login.html" security="none"></security:http>
	<security:http pattern="/user/login" security="none"></security:http>
    <security:http auto-config="true" use-expressions="true">
    	<security:form-login 
    		always-use-default-target="true" 
    		login-page="/view/login.html"
    		default-target-url="/welcome"
    		authentication-failure-url="/login?error"
			authentication-success-forward-url="/user/page2" />
       <!--特殊专门拦截请求1 权限相关，会在每次请求的时候都可能被使用，但认证则只会在session未建立的时候、securityContext未建立的时候-->
       <!-- 通道访问可以设置requires-channel="https"  -->
        <security:intercept-url pattern="/admin" 
            access="hasRole('ROLE_ADMIN')" /> 
		<!--特殊专门拦截请求2 -->
		<security:access-denied-handler error-page="/403"/>
        <security:intercept-url pattern="/data" access="hasRole('ROLE_USER')" />
        <!-- 全部拦截 -->
        <security:intercept-url pattern="/**" access="hasRole('ROLE_USER')" />
		<!--用基本验证 来覆盖前面的自动配置；本质上即加了“基本过滤Filter” -->
        <security:http-basic />
		<!--登出配置 -->
		<security:logout logout-success-url="/login?logout"/>
		<!-- 暂时不跨域认证拦截，即先放弃这种安全机制，以后增加这种机制 -->
		<security:csrf disabled="true" />
		<!--实行摘要认证 ,前面添加过滤器 (实现AbstractSecurityInterceptor 接口),只知道请求，是不知道用户信息和权限信息的-->
		<!--<security:custom-filter ref="digestFilter" position="BASIC_AUTH_FILTER" />
			<custom-filter ref="securityFilter" before="FILTER_SECURITY_INTERCEPTOR"/>, -->
		
</security:http>
<security:authentication-manager alias="authenticationManager">
      <!--   <security:authentication-provider >
             <security:user-service id="userService">
                <security:user authorities="ROLE_USER" name="tom"
                    password="tom" />
                <security:user authorities="ROLE_USER, ROLE_ADMIN"
                    name="admin" password="admin" />
            </security:user-service>
            
             <security:jdbc-user-service data-source-ref="dataSource"
                                        users-by-username-query="select username,password, enabled from users where username = ?"
                                        authorities-by-username-query="select username, role from user_roles where username = ?"/>
             
       </security:authentication-provider> -->
       <security:authentication-provider user-service-ref="hibernateUserDetailsService">
       
       </security:authentication-provider>
</security:authentication-manager>

<bean id="hibernateUserDetailsService" class="com.construct.persistence.security.HibernateUserDetailsService">
<property name="baseCollectionDao" ref="login_userdao" />
</bean>

<bean id="login_userdao" class="com.construct.psersistence.dao.IHUserDaoImpl">
 <property name="sessionFactory" ref="sessionFactory" />
 </bean>
</beans>     
